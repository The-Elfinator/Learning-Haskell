# Задание 1

 * `data Option a = None | Some a`
 * `data Pair a = P a a`
 * `data Quad a = Q a a a a`
 * `data Annotated e a = a :# e`, где `infix 0 :#`
 * `data Except e a = Error e | Success a`
 * `data Prioritised a = Low a | Medium a | High a`
 * `data Stream a = a :> Stream a`, где `infixr 5 :>`
 * `data List a = Nil | a :. List a`, где `infixr 5 :.`
 * `data Fun i a = F (i -> a)`
 * `data Tree a = Leaf | Branch (Tree a) a (Tree a)`

Вот столько различных типов. Для каждого из них надо имплементить функцию

```Haskell
mapF :: (a -> b) -> (F a -> F b)
```

Где F - соответствующий тип, то есть

```Haskell
mapOption      :: (a -> b) -> (Option a -> Option b)
mapPair        :: (a -> b) -> (Pair a -> Pair b)
mapQuad        :: (a -> b) -> (Quad a -> Quad b)
mapAnnotated   :: (a -> b) -> (Annotated e a -> Annotated e b)
mapExcept      :: (a -> b) -> (Except e a -> Except e b)
mapPrioritised :: (a -> b) -> (Prioritised a -> Prioritised b)
mapStream      :: (a -> b) -> (Stream a -> Stream b)
mapList        :: (a -> b) -> (List a -> List b)
mapFun         :: (a -> b) -> (Fun i a -> Fun i b)
mapTree        :: (a -> b) -> (Tree a -> Tree b)
```

А так же должны выполняться законы:
```Haskell
         mapF id  ≡  id
mapF f ∘ mapF g   ≡  mapF (f ∘ g)
```

По сути мы хотим чтобы наши контейнера были функторами, но препы запретили использовать что-то и сказали реализовывать всё руками. То есть мы хотим чтобы у нас были функции, которые могли работать со значениями в коробочке. То есть если есть функция `f :: a -> b`, то на выходе `mapF f` мы хотим иметь функцию `g :: F a -> F b`, которая принимает коробочку со значением и возвращает коробочку со значением

Однако надо реализовать всё своими руками, что ж этим мы и займёмся... Например, для `mapOption`:

Вот нам пришла некоторая функция f:

```Haskell
mapOption _ None = None
mapOption f (Some x) = Some (f x)
```

Что тут произошло? В `mapOption` пришла функция `f :: a -> b`  и пришёл `Option a` (тут `а` это тип, а не название аргумента).  Ну и что? Мы достали элемент из коробки (`None | Some x`), применили к `x` функцию `f` (`f x`, если нужно) и запихнули результат обратно в коробку (`None` не поменялся, `Some (f x)` изменился). Теперь почему это то, что нужно? Если посмотреть на тип `mapOption` то он имеет вид `(a -> b) -> Option a -> Option b`. Но так как `->` право ассоциативна, то можно расставить скобочки так `(a -> b) -> (Option a -> Option b)`, а кажется это ровно то, что мы хотели

Теперь если в `mapOption` передать только функцию `f :: a -> b` (эта штука называется каррирование), то на выходе получим функцию из `Option a` в `Option b`. Осталось проверить выполнение законов (для меня очевидно, что всё работает, но можно потестировать в ghci)

# Задание 2

Окей, теперь нам надо для всех наших типов из 1 задания (кроме `Tree`) создать функции

```Haskell
distF :: (F a, F b) -> F (a, b)
wrapF :: a -> F a
```

Что они делают? `wrapF` , как видим, запаковывает аргумент в соответствующую коробочку (казалось бы, ничего сложного). `distF` же в свою очередь принимает пару одинаковых коробочек, в которых запакованы разные значения, и возвращает коробочку с запакованной внутри парой

При этом от нас хотят выполнение следующих законов

```Haskell
distF (wrapF a, wrapF b)  ≅  wrapF (a, b)  // Гомоморфизм
distF (p, distF (q, r))   ≅  distF (distF (p, q), r)  // Ассоциативность
distF (wrapF (), q)  ≅  q  // левая идентичность (identity)
distF (p, wrapF ())  ≅  p  // правая идентичность (identity)
```

Однако не всё так просто. Во-первых, мы снова всё реализуем руками (можно использовать функции из задания 1, `(<>)` и `mempty` для `Annotated`). Во-вторых, `distPrioritised` из двух приоритетов должен взять больший, а `distList` должен создать декартово произведение

Давайте разбираться на примере:

```Haskell
wrapOption :: a -> Option a
wrapOption x = Some x
```

Думаю тут никаких вопросов нет. А что с `dist`?

```Haskell
distOption :: (Option a, Option b) -> Option (a, b)
distOption (x, y) = ?
```

Совершенно очевидно, что если оба элементы пары переданы через `Some` то вернём `Some` от пары. Тут ничего сложного. А если кто-то из них `None`? А если оба? Как реализовать такой кейс? Ну давайте думать логически. Давайте отталкиваться от выходного типа. Там `Option (a, b)`. Это значит, что на выходе либо `Some (a, b)`, либо `None`. Почему? Да потому что у нас конструктор `Option` такой. Тогда совершенно понятно, что если что-то `None`, что и на выходе `None` (а иначе как создать пару?)

С `Pair` и `Quad` проблем не должно возникнуть (просто смотрим на тип, который должен быть получен на выходе и на конструктор типа)

Приколы начинаются дальше: `Annotated`. Начнём с `wrapAnnotated`. Пришёл `х` типа `a`, мы хотим добавить к нему аннотацию типа `e`. Вопрос: какую брать? Мы то больше ничего не знаем. И тут нам помогает констрейнт `Monoid e` (а именно мы объявляем тип функции `wrapAnnotated :: Monoid e => a -> Annotated e a`). Почему `Monoid`? Потому что у нас там есть нейтральный элемент `mempty`, который мы и добавим в качестве аннотации к аргументу.
Окей, а что тогда с `distAnnotated`? У нас пришло 2 аннотированных "объекта" и мы хотим сами значения запихнуть в пару, и добавить аннотацию. Какую? Тут должно помочь что мы уже заикнулись про констрейнт для `wrap`. Только теперь нам нужна операция `(<>)`. Поэтому меняем тип функции на `distAnnotated :: Semigroup e => (Annotated e a, Annotated e b) -> Annotated e (a, b)` и теперь становится всё понятно (в аннотацию пихаем результат `<>` применённой к двум аннотациям пришедшим на вход)

Теперь `Except`. Тут полегче. Если где-то ошибка, то её и оставляем, иначе получаем пару `Success` которые переделаем в  `Success`  от пары (аналогично `Option`)

Приоритеты. Тут мне сначала не пришло в голову ничего гениальнее кроме как перебрать все возможные конструкторы. Единственное что, надо правильно выбрать конструктор для `wrap`, чтобы выполнялись законы. Потом чтобы за полный перебор не прилетел бан, я буквально руками писал реализацию для `Enum` так как нам ограничили `Prelude`

`Stream`. Тут так как не сказано другого, я просто соединил элементы двух стримов в пары соответственно. Стримы бесконечные, поэтому кажется такое действие логичным. Если не понятно, поясню. Вот у меня был стрим `x0 :> x1 :> x2 :> ...` и стрим `y0 :> y1 :> y2 :> ...`, которые пришли как аргументы. Давайте я просто на выходе отдам `(x0, y0) :> (x1, y1) :> (x2, y2) :> ...`. Кажется, это валидный стрим и ожидаемое поведение

А вот с листом всё куда хуже. Допустим, `wrap` понятно как работает (лист из одного элемента я думаю в состоянии написать те, кто читает это). А вот `dist` должен представлять декартово произведение. Как это сделать нормально? Именно этим вопросом я задался находясь в полусонном состоянии в 11 вечера... Давайте начнём с простого: один из аргументов пустой лист. Ну тогда декартово произведение невозможно (почему, спросите теорию множеств), значит отдадим пустой лист. Теперь считаем что оба листа непустые. Вот допустим, что один из листов содержит ровно 1 элемент. Тогда очев, что мы этот элемент в качестве пары добавим ко всем элементам другого листа. Получим лист пар. Но что делать, если элементов больше? Вот допустим, что в первом листе у нас было 2 элемента `[x0, x1]`, и был второй лист `y = [y0, y1, ..., ym]`. Мы умеем строить декартово произведение для листа из одного элемента (скажем для последнего), то есть `[(x1, y0), (x1, y1), ... (x1, ym)]`. Теперь у нас есть элемент `x0` и мы хотим построить для него декартово произведение и объединить с результатом. Но вот если мы например сможем просто взять пару `(x0, ym)` то можно быстро её добавить в результат. Дальше берём пару `(x0, y_{m-1})` и так далее.
Получается мы как бы идём с конца, то есть на выходе из рекурсивного вызова добавляем новую пару в результат. Осталось подумать как это лучше написать, и тут я не эксперт... Мне пришлось сделать небольшой говно-код по типу: отдельно построил произведение для `[x0]` и `y`, отдельно для `[x1]` и `y` и дальше написал функцию которая их объединит в один лист

И на конец, `Fun`. Тут `wrap` это лямбда, которая для любого аргумента вернёт то, что передано в функцию. Почему так? Ответ даст тип `wrap` и конструктор `Fun`. А вот с `dist` чуть по другому. Там тоже лямбда, но возвращает она пару. А вот элементами пары выступают результаты применения соответствующих функций к аргументу

# Задание 3

Для `Option`, `Except`, `Annotated`, `List` и `Fun` надо реализовать функцию `joinF :: F (F a) -> F a`. Что она делает? На вход приходит коробочка в коробочке, мы должны вернуть только одну коробочку. Как это делать? Ну вот на примере `Option`:

`joinOption :: Option (Option a) -> Option a`. У нас пришёл `Option` от `Option`.  Давай посмотрим ещё раз на конструктор `Option`: `data Option a = None | Some a` . А теперь заменим в нём `a` на `Option a` и получим `Option (Option a) = None | Some (Option a)`. Раскроем теперь внутренний `Option a` и получим такую вот вещь:

`data Option (Option a) = None | Some (None | Some a)`. Тогда всё что делает `join` это просто вернёт внутреннюю часть.

Однако мы должны удостовериться, что выполняются законы:
```Haskell
joinF (mapF joinF m)  ≡  joinF (joinF m)  // Ассоциативность
joinF      (wrapF m)  ≡  m  // левая и
joinF (mapF wrapF m)  ≡  m  // правая идентичности
```

Ну что ж, пошли писать код. C `Option` вроде разобрались. С `Except` аналогично. А вот для `Annotated` нужен констрейнт, так как мы не хотим терять аннотации. Какой констрейнт? Также как и в прошлой таске (`Semigroup e`). То есть функция `joinAnnotated` имеет тип `joinAnnotated :: Semigroup e => Annotated e (Annotated e a) -> Annotated e a`. С листом вроде всё понятно. Есть лист листов, хотим их объединить в один лист. Как это сделать лучше решайте сами. Я же примерно расскажу как сделал я. В общем если на `join` пришёл пустой лист, то пустым он и остаётся. Иначе я считаю что у меня есть 2 листа (один это голова, а другой результат `join` от хвоста). И написал функцию вспомогательную, которая конкатенирует эти 2 листа в один. Как? Ну вот у меня например когда 1 элемент в первом листе, и есть второй лист, то почему бы просто этот 1 элемент не отдать второму листу в качестве головы. А если там >1 элемента? Ну тогда я возьму последний, присоединю его ко второму листу, а потом к результату присоединю предпоследний, предпредпоследний и т.д.
Важно, так как на вход `join` приходит лист листов, то может быть ситуация вида `[[], [1, 2, 3], []]`. Тогда очев что в результате пустые листы просто должны быть пропущены, то есть на выходе должен быть получен лист вида `[1, 2, 3]`.

Ну и наконец функции: тут нам пришла функция `F ( i -> F (i -> a) )`. Мы же хотим просто иметь функцию `F (i -> a)`.  То есть на входе у нас `F f`, где `f :: i -> g`, `g :: Fun i a`. Надо как-то достать внутреннюю функцию. Как? Тут я понял что мне тяжело, поэтому запросил помощи. В общем, сначала я подумал, что всё что мы можем достать из аргумента, это просто внешнюю функцию. То есть нам приходит `joinFun F f`, где `f :: i -> Fun i a`.  На выходе мы хотим иметь тип `Fun i a`, поэтому мне помогли typed hole
`joinFun F f = F _`
Скомпилируем и увидим, что `_` должно иметь тип `i -> a`. Откуда взять что-то типа `i`? У нас ничего больше нет, поэтому напишем лямбду
`joinFun F f = F (\x -> _)`
Теперь `x :: i`, а `_ :: a`. Значит надо как-то достать функцию `i -> a` и применить её к `x` . Вопрос как? Давайте вспомним про `f`. Она имеет тип `f :: i -> Fun i a`. Тогда применим `f x`, получим `Fun i a`, то есть `joinFun F f = F (\x -> f x)`. Упс, типы не соответствуют. Мы же хотим `i -> a`, а получили `i -> Fun i a`. Но погодите, `f x` - содержит внутри функцию. То есть `F g = f x`, где `g :: i -> a`. Надо лишь достать `g` (паттерн-матчинг по конструктору) и применить её к `x`. Как достать `g`? Тут надо написать некую вспомогательную функцию, с помощью `where / let .. in`, чтобы сделать паттерн-матчинг по конструктору. Как это делать я предлагаю решить самостоятельно. Я знаю, что описал довольно тяжело, надо просто играться с `joinFun` и typed hole

# Задание 4

## State

```Haskell
data State s a = S { runS :: s -> Annotated s a }
```

Напомню, что `data Annotated e a = a :# e`, где `infix 0 :#`

Надо написать следующие функции 
```Haskell
mapState :: (a -> b) -> State s a -> State s b
wrapState :: a -> State s a
joinState :: State s (State s a) -> State s a
modifyState :: (s -> s) -> State s ()
```

Ну то есть ручками их реализовать. Что ж, тут вроде ничего такого сложного нет

Начнём с `mapState`. Вот у нас есть конструктор `S` от функции `runS :: s -> Annotated s a` (вот такую запись, что у нас есть, следует понимать как создание своего типа данных `State` с конструктором с названием `S` и полем `runS :: s -> Annotated s a`).
Тогда на вход `mapState` приходит некая функция `f` и старое состояние `oldState`. Ну раз `oldState` это "объект" типа `State`, то достанем от него поле `runS` (это можно сделать просто написав `S run` во входных аргументах функции). Ну а дальше нам надо разобраться с результатом. Ну раз там должно быть `State` то очев должен стоять конструктор `S` от чего-то. А это что-то - это функция (если быть точнее то новое поле `runS :: s -> Annotated s b`). так как ни от куда мы тип `s` не возьмём, то напишем лямбду:
```Haskell
mapState :: (a -> b) -> State s a -> State s b
mapState f (S run) = S (\x -> _)
```

Осталось понять что должно быть на месте `_`. Там должно быть `Annotated s b`, а у нас есть `x :: s, run :: s -> Annotated s a, f :: a -> b`. Тут нам на помощь придёт друг из задания 1, а именно `mapAnnotated :: (a -> b) -> Annotated s a -> Annotated s b`.  Дальше я думаю всё становится понятно. С `wrapState` вроде никаких проблем быть не должно. Просто оборачиваем `value` пришедшее на вход в `State`, то есть вызываем конструктор `State` от лямбды, которая создаёт `Annotated s a`. 
Теперь к `joinState`. Вот нам пришло `S outerRun` где `outerRun :: s -> Annotated s (State s a)`, мы хотим на выходе иметь просто `State s a`, то есть как бы достать внутренний `State`. 
Как быть? Давайте пока что напишем так
```Haskell
joinState :: State s (State s a) -> State s a
joinState (S outerRun) = _
```
Снова разберёмся, что там должно быть. Аналогично `mapState` на выходе поставим конструктор от лямбды, то есть
```Haskell
joinState (S outerRun) = S $ \x -> _
```
`_ :: Annotated s a`. Теперь посмотрим что у нас есть. `outerRun :: s -> Annotated s (State s a)`, `x :: s`. Ура, можем значит применить `outerRun x` и получить `<State s a> :# outerAnnotation`. Однако чтобы суметь так распаковать `Annotated` нам поможет вспомогательная функция `helper` которую определим с помощью `where`. Вот этот внутренний `State` теперь мы можем достать (аналогично как всегда достаём `State`), и помимо этого у нас есть `outerAnnotation`. Так давайте просто применим `outerAnnotation` к внутреннему `runS` и получим искомый `Annotated s a` 
С `modifyState` почти также как и с `wrapState`, только теперь нам пришло `func :: s -> s`, а `value = ()`

Теперь нам надо реализовать для `State` инстансы `Functor`, `Applicative`, `Monad`
Напомним, что для `Functor` нужен `fmap`, для `Applicative` - `pure` и `<*>`, а для `Monad` - `>>=`
```Haskell
class Functor f where
	fmap :: (a -> b) -> f a -> f b`
```
То есть в нашем случае при `f == State s` мы имеем:
```Haskell
instance Functor (State s) where
	fmap :: (a -> b) -> State s a -> State s b
```
Ну и если посмотреть внимательно, то можно увидеть, что это ничто иное как `mapState`

Теперь аппликатив:
```Haskell
instance Applicative (State s) where
	pure :: a -> State s a
	(<*>) :: State s (a -> b) -> State s a -> State s b 
```
Как видим, `pure` - это в точности `wrapState`, а вот `<*>` интереснее. У нас есть запакованная функция, то есть `S runFunc`, где `runFunc :: s -> Annotated s (a -> b)`, и есть запакованное значение `S runValue`, где `runValue :: s -> Annotated s a`. Мы как всегда хотим `State`, поэтому, на выходе снова у нас конструктор от лямбды:
```Haskell
...
	(<*>) (S runFunc) (S runValue) = S $ \x -> _
```
`_ :: Annotated s b`. Снова посмотрим что у нас есть, увидим что мы с помощью `helper` можем распаковать `Annotated` и получить что-то в духе `func :# annotFunc`, `value :# annotValue`. Ну хорошо, если со значениями всё понятно (`func value`), то что делать с аннотациями? Вот тут были разные варианты, вплоть до добавления констрейнта `Semigroup s` ради операции `<>`. Но к сожалению, такая реализация не проходит тесты. Поэтому рассуждаем в *интуиционистской* логике (на самом деле это контринтуитивно для меня). Вот у нас на выходе конструктор от лямбды. Аргумент это `x :: s`. Давайте от него запустим `runFunc` только. Получим `func :# annotFunc`. А вот уже имея  `annotFunc` пихнём его в `runValue` и получим  `value :# annotValue`. И вот этот `annotValue` должен быть аннотацией для нашего `res = func value`. 
Почему подход с `Semigroup s` не сработал? Всё потому что мы на самом деле оперируем функциями, и если потом вызывать такой `Applicative`, то проблема начнёт возникать, что аргумент `x` будет записываться не один раз, что приведёт к проблемам. Это будет понятно после `instance Monad`. Вот пример использования `Applicative State`
![[Pasted image 20231105140007.png]]

Монада:
```Haskell
instance Monad (State s) where
	(>>=) :: State s a -> (a -> State s b) -> State s b
```

Вот тут уже треш какой-то. Тут честно уже говнокод, надеюсь не забанят.
В общем, давайте разбираться. Вот у нас снова есть как бы входной аргумент `runArg`, и есть функция, которая из `value`, доставаемого из `State s a` делает `State s b`. Ну окей, давайте рассуждать аналогично `Applicative`. Снова начнём с того, от чего везде отталкивались - конструктор от лямбды
```Haskell
...
	(>>=) (S runArg) fToState = S $ \x -> _
```
Здесь мы не так много можем достать сразу, так что придётся писать кучу `helper`-функций (на самом деле штуки 2-3). В общем, у нас снова `_ :: State s b`, `runArg x :: Annotated s a`, `fToState :: a -> State s b`. Окей, достанем с помощью первого `helper` `value :# annotValue`. Теперь мы можем применить `fToState value` и получить `State s b`. С помощью второго `helper` мы распакуем этот `State s b` применив `runSRes annotValue`, и получим `Annotated s b`, который так давно хотели

Зачем всё это? Для следующих приколов:
```Haskell
runS (do modifyState f; modifyState g; return a) x
  ≡
a :# g (f x)
```

Очень интересно, согласен *(это сарказм, если что)*

## Expression

Да-да, те самые `expression` которые все полюбили ещё с первого курса

В общем надо определить структуру данных
```Haskell
data Prim a =
    Add a a      -- (+)
  | Sub a a      -- (-)
  | Mul a a      -- (*)
  | Div a a      -- (/)
  | Abs a        -- abs
  | Sgn a        -- signum

data Expr = Val Double | Op (Prim Expr)
```

И для удобства записи такие инстансы

```Haskell
instance Num Expr where
  x + y = Op (Add x y)
  x * y = Op (Mul x y)
  ...
  fromInteger x = Val (fromInteger x)

instance Fractional Expr where
  ...
```

Тут я верю, что никаких проблем не возникнет (если что `Fractional Expr` для деления и для перевода из дробных чисел в наш `Expr`)
Так что, выражение вида `(3.14 + 1.618 :: Expr)` должно породить синтаксическое дерево
```Haskell
Op (Add (Val 3.14) (Val 1.618))
```

Ну а теперь, используя `do`-нотацию для нашего `State`, а также `pure`, `modifyState`, определить функцию 
```Haskell
eval :: Expr -> State [Prim Double] Double
```

В добавок к вычислению результата, мы ещё храним историю вычислений на каждом шаге, например:
```Haskell
runS (eval (2 + 3 * 5 - 7)) []
  ≡
10 :# [Sub 17 7, Add 2 15, Mul 3 5]
```
Голова листа - последняя операция, сделано для того чтобы новая операция занимала О(1) времени добавления лога

Ну что ж, п\*\*\*\*ц

Давайте начнём с простого: ~~закроем это задание~~ почитаем про `do`-нотацию, чтобы понять, как она работает. Для этого есть куча полезной инфы, которую я верю что ты в состоянии найти. Я же скорее скажу, что я делал в решении задания

Итак, теперь реально начнём с простого: `eval (Val x)`. Ну согласись, что проще некуда. Давай разберёмся, что мы вообще хотим. Мы хотим чтобы у нас вычислялось выражение и на каждом шаге в аннотацию (голову листа) записывалось то, что мы сделали на этом шаге (см. пример выше)
А что мы хотим, когда вычислили константу? Ничего. Серьёзно, нам не надо писать что мы вычислили константу, так что мы не изменяем `State` никак, только вычисляем значение. Теперь как это сделать? У нас `eval` возвращает `State [Prim Double] Double`. Помним, что `State` это `S $ \arg -> _`, где `_ :: Annotated [Prim Double] Double` , а `arg :: [Prim Double]` в нашем случае. Ну тогда 
```Haskell
eval (Val x) = S $ \arg -> x :# arg
```
Это можно записать проще через `do`-нотацию, а именно
```Haskell
eval (Val x) = return x
```
Вау, вот это да! А как быть с остальными штуками? Их так легко не запишешь. Согласен, поэтому будем по-немногу разбираться. Давай сначала с унарной функцией
```Haskell
eval (Op (Abs x)) = ???
```
Что мы хотим тут? Мы хотим рекурсивно выполнить `eval x`, так как `x :: Expr` (да, там может быть что угодно). Ну выполнили мы, теперь имеем `res = eval x :: Double`. Опа, у нас собирается выполняться операция `Abs Double`, поэтому мы хотим записать это в голову нашего листа аннотаций. И тут нам поможет наш друг `modifyState`. В нашем случае он имеет тип `modifyState :: ([Prim Double] -> [Prim Double]) -> State [Prim Double] ()`. Тут `()` - это **Unit!!!** Что такое Unit я думаю ты в состоянии понять и без меня. Окей, а чем нам поможет тут `modifyState`? А вот чем: запись нового шага выполнения будет выглядеть так `modifyState (Abs res :)`. То, что в скобках, это частичное применение операции `(:)` ( конкатенация списка, ну то есть `list = head : tail`, если помнишь об этом). Здесь оно преобразуется в функцию, которая примет лист и в его голову запишет `Abs res`. Ну окей, и теперь всё, что нам осталось это наконец выполнить этот несчастный `abs`. Итого у нас такой порядок действий:
 * Рекурсивный вызов `res = eval x`
 * Модифицируем аннотацию выполняя `modifyState (Abs res :)`
 * Выполняемся и возвращаем результат, то есть `return $ abs res`
Теперь, `do`-нотация поможет в выполнении всей этой штуки. Имеем:
```Haskell
eval (Op (Abs x)) = do
	res <- eval arg
	modifyState (Abs res :)
	return $ abs res
```
Вот, теперь у нас есть eval от модуля. Аналогично делается `Sgn`. А что с бинарными операциями? А ничего сверхъестественного, просто вместо одного аргумента у нас 2.
Для начала предлагаю написать всё это прям так с кучей копи-пасты, и только потом думать как вынести её.

# Заключение

Я понимаю, что последнее задание тяжёлое, сам на него потратил наверное дня 2-3, здесь надо уже очень хорошо понимать монады и `do`-нотацию, чтобы осознать, как писать `eval`. 

Я постараюсь максимально подробно и понятно описывать решения, но дальше, я боюсь, базовых знаний Haskell будет просто недостаточно для понимания написанного

Если не чувствуешь себя уверенным в последней таске, то потрать существенную часть времени на пересмотр лекций, просмотр доп материалов, благо их можно найти.

Остались вопросы - контакты в Bio аккаунта. Удачи!
