### Задание 1: сделать правую свёртку бинарного дерева

```Haskell
data Tree a = Leaf | Branch !Int (Tree a) a (Tree a)
	deriving (Show)
```
```Haskell
tfoldr :: (a -> b -> b) -> b -> Tree a -> b
```
```Haskell
treeToList :: Tree a -> [a]    -- output list is sorted
treeToList = tfoldr (:) []
```
Грубо говоря, `tfoldr` принимает в качестве аргументов функцию над элементов дерева и контейнером этих элементов, возвращающую контейнер элементов, сам контейнер, текущий узел дерева (по дефолту корень) и возвращает новый контейнер
Звучит сложно
Запустим рекурсивно tfoldr от левого сына, получим 
`leftColletion :: b`,
Дальше вызовем `collection = func nodeValue leftCollection :: b` и отправим её в качестве аргумента на `tfolr` правого сына, то есть `tfoldr func collection right`
Так, вроде звучит довольно легко, в чём подвох?
Так, стоп, у нас правая свёртка
Тогда чуть по другому: сначала от правого сына, потом текущее value, потом идём в левого сына

### Задание 2: реализовать свой split и join
#### splitOn

```Haskell
splitOn :: Eq a => a -> [a] -> NonEmpty [a]
```
```Haskell
ghci> splitOn '/' "path/with/trailing/slash/"
["path", "with", "trailing", "slash", ""]
```
Так, ну что получается? Для определённости я буду называть аргументы `separator`( `sep`) и `list`
Очев, что результат это список списков
Давайте идти по элементам листа (с конца, так как быстрее достать head, чем last, и будем рекурсивно вызываться). Пусть в какой-то момент мы накопили результат 
То есть у нас шаг рекурсии выглядит следующим образом:
$list = [..., current, ...], result = [[elements], [...]]$
если `current` это `sep`, то создаём новый лист, то есть $result' = [[], [elements], [...]]$
иначе, добавляем `current` в голову $result$
Звучит несложно, пошёл говнокодить
#### joinWith
```Haskell
joinWith :: a -> NonEmpty [a] -> [a]
```
```Haskell
ghci> "import " ++ joinWith '.' ("Data" :| "List" : "NonEmpty" : [])
"import Data.List.NonEmpty"
```
Инверсия функции `splitOn`
Идём по непустому списку списков, пусть в какой-то момент вызывались
$source = [..., currentList, ...], currentList = [..., element, ...], result = [head, ...]$
Если у нас currentList пустой, то добавляем к результату сепаратор, иначе добавляем элемент
В целом работает, но с некоторыми особенностями (а именно надо грамотно подойти к `NonEmpty`)

#### Task3 - Foldable
Есть функция foldMap, её тип: 
```Haskell
 (Foldable t, Monoid m) => (a -> m) -> t a -> m
```
Очень сложно
В нашем случае она берёт какую-то функцию переводящую из a в Monoid a, и идёт по списку, применяя её к элементу и сохраняя результат `mappend`-ом
Грубо говоря
Пример:
```Haskell
>>> foldMap Sum [1, 3, 5] 
Sum {getSum = 9}
```
Что тут происходит?
Мы взяли 1, Применили к нему Sum (то есть вызвали конструктор класса Sum), получили новый "объект" и к результату (изначально это mempty) добавили mappend-ом `Sum(1)`
И так далее по списку
Очев, тут нечто похожее
Более того, тут уже есть всё что нужно исходя из типов `mcat` и `epart`
Тогда эти функции это просто частично применённый `foldMap`  с какой-то функцией, то есть `foldMap func`
Осталось только эту `func` реализовать
#### Task 4 - Semigroups & Monoids

##### 1. Реализовать instance Semigroup для ListPlus
```Haskell
data ListPlus a = a :+ ListPlus a | Last a
infixr 5 :+
```
Итак, для начала определим операцию `:+`
Как очевидно из конструктора `ListPlus` операция в качестве аргументов принимает элемент типа `a` и `ListPlus a`, и возвращает новый экземпляр класса `ListPLus a`
Как он работает? Пусть у нас аргументы зовутся `x y`
Очев, что `y` это либо `Last a`, либо `a :+ ListPlus a`
В первом случае мы будем иметь `x :+ Last y`, во втором `x :+ y1 :+ ListPlus y2`
На этом у нас построен конструктор нашего `data ListPlus a`
Теперь надо определить `<>` для Semigroup
`<> :: ListPlus a -> ListPLus a -> ListPlus a`
1. Слева и справа пришли Last: просто конкатенируем через `:+`
2. Last только слева: просто добавить новый элемент в список с помощью  `:+` (пункты 1 и 2 имеют общую реализацию)
3. Last только справа (`head :+ (tail <> argY)`)
4. Нет Last'ов (последовательно применяем `<>` к голове второго аргумента)
Будет ли `<>` ассоциативной?
`(x <> y) <> z ==? x <> (y <> z)`
Да, это же конкатенация
##### 2. instance Smigroup для Inclusive
Перебрать 9 вариантов, контекст для a, b


